# 📅 Day 25 – Bench 확장(6→9) + Drag Drop(보드↔벤치) + Roll 버튼 연결 구조 확정

## ✅ 오늘 목표
1) **벤치 슬롯 확장 (6 → 9)**  
   - 슬롯 수를 늘려도 코드가 깨지지 않게(하드코딩 최소화) 유지  
2) **드래그 기반 배치의 기반 만들기**  
   - 유닛을 마우스로 끌어서 보드(타일) / 벤치(슬롯)에 드롭 가능하게  
   - 벤치 유닛이 전투에 참여하지 않도록(InBattle 제어)  
3) **Roll 버튼 클릭 시 Roll 되도록 연결 구조 확정**  
   - UI 이벤트 → GridManager가 규칙 처리(롤/골드/리프레시)하는 방향


---

## 🧱 오늘 변경 사항 요약

### 1) BenchSlot 6개 → 9개로 확장
- Hierarchy에서 BenchSlot 오브젝트를 **총 9개**가 되도록 추가 배치
- `BenchManager.slots` 리스트에 **9개 슬롯 등록**
- `BenchManager`의 Auto Layout 덕분에
  - `slotSpacing`, `localStart`만으로 위치 정렬 가능
  - 슬롯 개수를 바꿔도 코드 수정 없이 유지됨

✅ 기대 효과  
- TFT처럼 벤치가 “고정 슬롯”이라는 전제를 유지하면서도  
  **6/8/9/10 등 슬롯 수 변경이 쉬운 구조**가 됨

---

### 2) DragUnit 기반 드래그/드롭 로직 구현
- `DragUnit.cs`를 유닛 프리팹(또는 유닛 오브젝트)에 부착
- 드래그 동작:
  - `OnMouseDown()`에서 시작 위치(startPos) 저장 + dragOffset 계산
  - `OnMouseDrag()`에서 마우스 따라 유닛 이동
- 드롭 동작:
  - 우선 **타일(Tile) 드롭 시도**
  - 타일 실패하면 **벤치 슬롯(BenchSlot) 드롭 시도**
  - 둘 다 실패하면 원위치 복귀

✅ 핵심 룰
- 보드(타일)에 올라가면 `unit.SetInBattle(true)`
- 벤치(슬롯)로 내려가면 `unit.SetInBattle(false)`  
  → 벤치 유닛이 전투 참여하는 버그 방지

---

### 3) Roll 버튼 연결 방향 확정
- Roll은 단순 UI 기능이 아니라 “게임 규칙(롤/골드/상점 갱신)”에 포함되므로  
  **GridManager가 UI_Roll()로 처리하는 방식이 맞다고 판단**
- 구현 방향:
  - 버튼 클릭 → GridManager.UI_Roll() 호출
  - 내부에서 `shop.Roll()` + `shopUI.Refresh()` 수행

✅ 목적
- UI는 “요청만” 하고, 규칙은 GridManager가 담당  
- 추후 골드 차감/전투 중 롤 금지/리롤 비용 증가 등 확장하기 쉬움

---

## 🧪 교차검증 체크리스트(오늘 기준)
### 1) 이동 자연스러움 유지
- 보드 위 유닛은 기존처럼 스르륵 이동/Separation 동작 유지 ✅

### 2) 공격 정상 발동 + 쿨다운 정상
- 보드 유닛만 공격/타겟팅 진행 ✅  
- 벤치 유닛은 `InBattle=false`로 전투 제외 ✅

### 3) 라운드 종료/보상/정리/다음 라운드 로그 1회씩 유지
- Drag/Bench 변경이 라운드 흐름에 영향 주지 않도록 유지 ✅

추가 확인
- 벤치가 꽉 찼을 때 드롭 시 원위치 복귀 ✅(실패 분기)

---

## 📌 남은 할 일 (Next)
1) **보드 → 벤치 드롭 완성도 강화**
   - 슬롯이 이미 찼을 때 “스왑(교환)” 여부 결정
   - 벤치 슬롯이 아닌 근처 드롭 시 “가장 가까운 슬롯 스냅” 여부 결정

2) **Roll 버튼 실제 연결 마무리**
   - Modern UI 버튼 이벤트 구조에 맞춰 자동 바인딩 또는 클릭 이벤트 연결 확정
   - Roll 시 사운드/애니메이션/리롤 비용(추후)

3) **UX 개선**
   - 드래그 중 타일/슬롯 하이라이트(가능/불가 표시)
   - 드래그 드롭 성공/실패 시 피드백(색/사운드)

---

